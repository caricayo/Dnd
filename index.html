<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>GPT-4 / GPT-5 Switcher</title>
    <style>
      body { font-family: system-ui, sans-serif; max-width: 760px; margin: 2rem auto; padding: 0 1rem; }
      label { display: inline-block; margin: 0.5rem 0; }
      textarea { width: 100%; }
      pre { white-space: pre-wrap; background: #111; color: #eee; padding: 1rem; border-radius: 8px; min-height: 120px; }
      .row { display: flex; gap: 12px; align-items: center; }
      select, button { height: 36px; }
    </style>
  </head>
  <body>
    <h1>Chat with GPT-4 or GPT-5</h1>

    <div class="row">
      <label for="model">Model:</label>
      <select id="model">
        <option value="gpt-4o">GPT-4 (4o)</option>
        <option value="gpt-5">GPT-5</option>
      </select>
    </div>

    <label for="prompt">Message</label>
    <textarea id="prompt" rows="4" placeholder="Ask me anything..."></textarea>
    <div class="row">
      <button id="send">Send</button>
      <button id="clear">Clear</button>
    </div>

    <h3>Response</h3>
    <pre id="out"></pre>

    <script>
      // Point this to your Worker
      const ENDPOINT = 'https://YOUR-WORKER-SUBDOMAIN.workers.dev/chat';

      function append(text) {
        const out = document.getElementById('out');
        out.textContent += text;
      }

      document.getElementById('clear').onclick = () => {
        document.getElementById('out').textContent = '';
      };

      document.getElementById('send').onclick = async () => {
        const out = document.getElementById('out');
        out.textContent = '';

        const content = document.getElementById('prompt').value.trim();
        const model = document.getElementById('model').value; // "gpt-4o" or "gpt-5"

        const resp = await fetch(ENDPOINT, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            model, // sent to backend; backend validates allowlist
            messages: [{ role: 'user', content }]
          })
        });

        if (!resp.ok || !resp.body) {
          append(`Error: ${resp.status}`);
          return;
        }

        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });

          // Parse SSE lines as they arrive
          const lines = buffer.split('\n');
          // keep the last partial line in buffer
          buffer = lines.pop() || '';

          for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed.startsWith('data:')) continue;

            const payload = trimmed.slice(5).trim(); // after "data:"
            if (!payload || payload === '[DONE]') continue;

            try {
              const json = JSON.parse(payload);
              const delta = json.choices?.[0]?.delta?.content || '';
              if (delta) append(delta);
            } catch {
              // ignore malformed partials
            }
          }
        }
      };
    </script>
  </body>
</html>
